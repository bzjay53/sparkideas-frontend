-- IdeaSpark v2.0 Database Schema
-- Supabase PostgreSQL Schema for Real-time Pain Point Analysis

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- Pain Points Collection Table
CREATE TABLE IF NOT EXISTS pain_points (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    source TEXT NOT NULL CHECK (source IN ('reddit', 'google', 'naver', 'linkedin', 'twitter')),
    source_url TEXT NOT NULL,
    sentiment_score DECIMAL(3,2) DEFAULT 0.0,
    trend_score DECIMAL(3,2) DEFAULT 0.0,
    keywords TEXT[] DEFAULT '{}',
    category TEXT DEFAULT 'general',
    collected_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Business Ideas Generated by AI
CREATE TABLE IF NOT EXISTS business_ideas (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    target_market TEXT NOT NULL,
    revenue_model TEXT NOT NULL,
    market_size TEXT NOT NULL,
    implementation_difficulty INTEGER CHECK (implementation_difficulty BETWEEN 1 AND 5),
    confidence_score DECIMAL(5,2) NOT NULL CHECK (confidence_score BETWEEN 0 AND 100),
    pain_point_ids UUID[] DEFAULT '{}',
    ai_analysis JSONB DEFAULT '{}',
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Telegram Message Delivery Log
CREATE TABLE IF NOT EXISTS telegram_messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    chat_id TEXT NOT NULL,
    message_type TEXT NOT NULL CHECK (message_type IN ('daily_digest', 'single_idea', 'alert')),
    business_idea_ids UUID[] DEFAULT '{}',
    message_content TEXT NOT NULL,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    success BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User Management
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    display_name TEXT,
    telegram_chat_id TEXT,
    notification_preferences JSONB DEFAULT '{"daily_digest": true, "instant_alerts": false}',
    subscription_tier TEXT DEFAULT 'free' CHECK (subscription_tier IN ('free', 'pro', 'business')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Community Platform Posts
CREATE TABLE IF NOT EXISTS community_posts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    tags TEXT[] DEFAULT '{}',
    category TEXT NOT NULL CHECK (category IN ('자랑', '공유', '외주', '협업')),
    likes_count INTEGER DEFAULT 0,
    comments_count INTEGER DEFAULT 0,
    project_status TEXT DEFAULT 'idea' CHECK (project_status IN ('idea', 'development', 'launched', 'completed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Community Comments
CREATE TABLE IF NOT EXISTS community_comments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id UUID NOT NULL REFERENCES community_posts(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    parent_comment_id UUID REFERENCES community_comments(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Project Matching System
CREATE TABLE IF NOT EXISTS project_matches (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    requester_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    post_id UUID NOT NULL REFERENCES community_posts(id) ON DELETE CASCADE,
    match_score DECIMAL(3,2) DEFAULT 0.0,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'completed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for Performance
CREATE INDEX IF NOT EXISTS idx_pain_points_source ON pain_points(source);
CREATE INDEX IF NOT EXISTS idx_pain_points_collected_at ON pain_points(collected_at DESC);
CREATE INDEX IF NOT EXISTS idx_pain_points_sentiment ON pain_points(sentiment_score DESC);
CREATE INDEX IF NOT EXISTS idx_pain_points_trend ON pain_points(trend_score DESC);
CREATE INDEX IF NOT EXISTS idx_pain_points_keywords ON pain_points USING GIN(keywords);

CREATE INDEX IF NOT EXISTS idx_business_ideas_confidence ON business_ideas(confidence_score DESC);
CREATE INDEX IF NOT EXISTS idx_business_ideas_generated_at ON business_ideas(generated_at DESC);
CREATE INDEX IF NOT EXISTS idx_business_ideas_difficulty ON business_ideas(implementation_difficulty);

CREATE INDEX IF NOT EXISTS idx_telegram_messages_sent_at ON telegram_messages(sent_at DESC);
CREATE INDEX IF NOT EXISTS idx_telegram_messages_success ON telegram_messages(success);

CREATE INDEX IF NOT EXISTS idx_community_posts_category ON community_posts(category);
CREATE INDEX IF NOT EXISTS idx_community_posts_created_at ON community_posts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_community_posts_likes ON community_posts(likes_count DESC);
CREATE INDEX IF NOT EXISTS idx_community_posts_tags ON community_posts USING GIN(tags);

-- Full Text Search
CREATE INDEX IF NOT EXISTS idx_pain_points_search ON pain_points USING GIN(to_tsvector('english', title || ' ' || content));
CREATE INDEX IF NOT EXISTS idx_business_ideas_search ON business_ideas USING GIN(to_tsvector('english', title || ' ' || description));
CREATE INDEX IF NOT EXISTS idx_community_posts_search ON community_posts USING GIN(to_tsvector('korean', title || ' ' || content));

-- Triggers for updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_pain_points_updated_at BEFORE UPDATE ON pain_points
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_business_ideas_updated_at BEFORE UPDATE ON business_ideas
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_community_posts_updated_at BEFORE UPDATE ON community_posts
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_community_comments_updated_at BEFORE UPDATE ON community_comments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_project_matches_updated_at BEFORE UPDATE ON project_matches
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Row Level Security (RLS) Policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE community_posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE community_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE project_matches ENABLE ROW LEVEL SECURITY;

-- Users can only see and edit their own data
CREATE POLICY "Users can view own profile" ON users
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON users
    FOR UPDATE USING (auth.uid() = id);

-- Community posts are publicly readable but users can only edit their own
CREATE POLICY "Community posts are publicly readable" ON community_posts
    FOR SELECT USING (true);

CREATE POLICY "Users can create posts" ON community_posts
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can edit own posts" ON community_posts
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own posts" ON community_posts
    FOR DELETE USING (auth.uid() = user_id);

-- Comments follow similar pattern
CREATE POLICY "Comments are publicly readable" ON community_comments
    FOR SELECT USING (true);

CREATE POLICY "Users can create comments" ON community_comments
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can edit own comments" ON community_comments
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own comments" ON community_comments
    FOR DELETE USING (auth.uid() = user_id);

-- Project matches are visible to involved parties
CREATE POLICY "Project matches visible to participants" ON project_matches
    FOR SELECT USING (auth.uid() = requester_id OR auth.uid() = provider_id);

CREATE POLICY "Users can create project matches" ON project_matches
    FOR INSERT WITH CHECK (auth.uid() = requester_id);

CREATE POLICY "Participants can update matches" ON project_matches
    FOR UPDATE USING (auth.uid() = requester_id OR auth.uid() = provider_id);

-- Sample data for testing
INSERT INTO users (email, display_name, telegram_chat_id, subscription_tier) VALUES
('test@example.com', 'Test User', '1394057485', 'free');

-- Analytics Views
CREATE OR REPLACE VIEW daily_analytics AS
SELECT 
    DATE(created_at) as date,
    COUNT(*) as total_pain_points,
    AVG(sentiment_score) as avg_sentiment,
    AVG(trend_score) as avg_trend,
    COUNT(DISTINCT source) as active_sources
FROM pain_points 
GROUP BY DATE(created_at)
ORDER BY date DESC;

CREATE OR REPLACE VIEW top_business_ideas AS
SELECT 
    title,
    description,
    confidence_score,
    implementation_difficulty,
    created_at
FROM business_ideas 
WHERE confidence_score >= 85
ORDER BY confidence_score DESC, created_at DESC
LIMIT 20;

-- Function to get trending keywords
CREATE OR REPLACE FUNCTION get_trending_keywords(days_back INTEGER DEFAULT 7)
RETURNS TABLE(keyword TEXT, frequency BIGINT) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        unnest(keywords) as keyword,
        COUNT(*) as frequency
    FROM pain_points 
    WHERE created_at >= NOW() - INTERVAL '%s days', days_back
    GROUP BY unnest(keywords)
    ORDER BY frequency DESC
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;